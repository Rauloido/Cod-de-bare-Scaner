<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Barcode Generator & Scanner</title>
        <link rel="manifest" href="manifest.json">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
        <meta name="apple-mobile-web-app-title" content="Barcode App">
        <link rel="apple-touch-icon" href="icon-192.png">
        <style>
            :root{--bg:#121212;--header:#000000;--panel:#1e1e1e;--text:#ffffff;--muted:#808080}
            .light-mode{--bg:#f6f7fb;--header:#132b52;--panel:#ffffff;--text:#111;--muted:#666}
            body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;margin:0;padding:0;background:var(--bg);color:var(--text)}
            header{padding:12px 16px;background:var(--header);color:white}
            .wrap{max-width:980px;margin:18px auto;padding:12px}
            .tabs{display:flex;gap:8px;margin:0;padding:8px 12px;border-radius:12px;background:rgba(0,0,0,0.6);position:fixed;left:50%;transform:translateX(-50%);bottom:12px;backdrop-filter:blur(8px);box-shadow:0 6px 18px rgba(0,0,0,0.6)}
            button.tab{padding:10px 14px;border:0;background:transparent;color:var(--muted);border-radius:10px;font-weight:600}
            button.tab.active{background:transparent;color:var(--text)}
            .panel{background:var(--panel);padding:12px;border-radius:8px;border:1px solid rgba(255,255,255,0.03)}
            /* scanner overlay */
            .scanner-wrap{position:relative;border-radius:12px;overflow:hidden;background:#000}
            .scanner-wrap video{display:block;width:100%;height:100%;object-fit:cover;background:#000}
            .scanner-overlay{position:absolute;inset:0;pointer-events:none}
            .scanner-guide{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:78%;height:34%;border-radius:12px;box-shadow:0 0 0 9999px rgba(0,0,0,0.25) inset}
            .scanner-guide:before,.scanner-guide:after{content:'';position:absolute;width:22px;height:22px;border:2px solid rgba(255,255,255,0.85);border-radius:6px}
            .scanner-guide:before{left:-10px;top:-10px;border-right:none;border-bottom:none}
            .scanner-guide:after{right:-10px;bottom:-10px;border-left:none;border-top:none}
            .red-line{position:absolute;left:10%;right:10%;height:2px;top:50%;transform:translateY(-1px);background:rgba(255,0,0,0.9);box-shadow:0 0 8px rgba(255,0,0,0.4)}
            .scan-flash{position:absolute;inset:0;background:rgba(255,255,255,0.08);opacity:0;transition:opacity .18s ease}
            .scan-active .scan-flash{opacity:1}
            .row{display:flex;gap:12px;align-items:center}
            /* mobile-optimized controls */
            @media(max-width:600px){
                .grid{grid-template-columns:1fr}
                .tabs{flex-direction:row}
                button.tab{flex:1;padding:14px}
                .actions button{padding:10px 12px;font-size:15px}
            }
            .big{padding:12px 16px;border-radius:10px;font-size:16px}
            input,textarea{width:100%;padding:12px;border:1px solid rgba(255,255,255,0.06);border-radius:10px;background:transparent;color:var(--text);outline:none}
            input:focus,textarea:focus{box-shadow:0 0 0 3px rgba(128,128,128,0.08)}
            label{font-weight:600;margin-bottom:6px;display:block}
            .grid{display:grid;grid-template-columns:1fr 320px;gap:12px}
            img.thumb{max-width:100%;border-radius:6px;border:1px solid rgba(0,0,0,0.06)}
            .product{border-bottom:1px solid rgba(0,0,0,0.06);padding:8px 0}
            .actions{display:flex;gap:8px}
            small.hint{color:var(--muted)}
            footer{padding:14px;text-align:center;color:var(--muted)}
            #insecure-warning{background:#ffefef;color:#801010;padding:10px;border-radius:6px;margin-bottom:12px;border:1px solid #ffd6d6}
        </style>
        <!-- Barcode generator -->
        <script src="https://cdn.jsdelivr.net/npm/jsbarcode@3.11.5/dist/JsBarcode.all.min.js"></script>
        <!-- ZXing for scanning (browser UMD) -->
        <script src="https://cdn.jsdelivr.net/npm/@zxing/library@0.18.6/umd/index.min.js"></script>
        <!-- ExcelJS + FileSaver for exporting images into XLSX -->
        <script src="https://cdn.jsdelivr.net/npm/exceljs@4.3.0/dist/exceljs.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
        <!-- SheetJS kept for imports -->
        <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
        <!-- docx for Word export (per user request) -->
        <script src="https://unpkg.com/docx@7.1.0/build/index.js"></script>
        <!-- Tesseract.js for OCR -->
        <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.2/dist/tesseract.min.js"></script>
    </head>
    <body>
        <header>
            <div style="max-width:980px;margin:0 auto;display:flex;justify-content:space-between;align-items:center">
                <div><strong>Barcode Generator & Scanner</strong></div>
                <div style="display:flex;gap:10px;align-items:center">
                  <div style="font-size:13px;opacity:.95">Two modes: Generate ↔ Scan • Works on phones</div>
                  <button id="btn-darkmode" title="Toggle dark mode" style="padding:6px 10px;border-radius:6px;border:none;background:rgba(255,255,255,0.15);color:white">Dark</button>
                </div>
            </div>
        </header>
        <main class="wrap">
            <div id="insecure-warning" style="display:none">
                <strong>Camera blocked:</strong> This page must be served over HTTPS (for example, via GitHub Pages) or from <code>localhost</code> for camera access. Deploy to GitHub Pages or serve over HTTPS to enable camera permissions.
            </div>
            <div class="tabs">
                <button class="tab active" id="tab-generate">Generate</button>
                <button class="tab" id="tab-scan">Scan</button>
                <button class="tab" id="tab-products">Products</button>
                <button class="tab" id="tab-receipt">Bon / Setări</button>
            </div>

            <div id="undo-toast" style="display:none;margin:10px 0;padding:10px;border-radius:6px;background:#fff3cd;border:1px solid #ffeeba;display:flex;align-items:center;gap:8px">
                <div id="undo-text" style="flex:1;color:#664d03"></div>
                <button id="undo-btn" style="padding:6px 10px">Undo</button>
            </div>

            <div id="panel-generate" class="panel">
                <div class="grid">
                    <div>
                        <label for="pname">Name</label>
                        <input id="pname" placeholder="Product name">

                        <label for="pdesc">Description</label>
                        <textarea id="pdesc" rows="3" placeholder="Short description"></textarea>

                        <label for="pstock">Stock / Number</label>
                        <input id="pstock" placeholder="Quantity or SKU number">

                        <label for="pprice">Price</label>
                        <input id="pprice" placeholder="Price (e.g. 9.99)">

                        <label for="purl">Product URL (optional)</label>
                        <input id="purl" placeholder="https://example.com/product-page">

                        <label for="pcode">Barcode value (optional)</label>
                        <input id="pcode" placeholder="Leave empty to auto-generate numeric code">

                        <label for="pimage">Image (optional)</label>
                        <input id="pimage" type="file" accept="image/*">

                        <div id="image-preview" style="margin-top:8px;display:none"><strong>Image preview</strong><div style="margin-top:6px"><img id="image-preview-img" src="" class="thumb"></div></div>

                        <div style="margin-top:10px" class="actions">
                            <button id="btn-generate">Generate Barcode</button>
                            <button id="btn-save" disabled>Save Product</button>
                        </div>

                        <div style="margin-top:10px">
                            <svg id="barcode"></svg>
                        </div>

                        <div style="margin-top:8px">
                            <button id="btn-download" disabled>Download Barcode PNG</button>
                        </div>
                    </div>

                    <!-- products moved to dedicated Products tab -->
                </div>
            </div>

            <div id="panel-products" class="panel" style="display:none">
                <div>
                    <div style="display:flex;justify-content:space-between;align-items:center">
                        <strong>Products</strong>
                        <div class="actions">
                            <button id="btn-export">Export Excel</button>
                            <button id="btn-import">Import Excel</button>
                            <input id="import-file" type="file" accept=".xlsx,.xls,.csv" style="display:none">
                        </div>
                    </div>

                    <div id="products-list" style="margin-top:8px;max-height:640px;overflow:auto"></div>
                </div>
            </div>

            <div id="panel-receipt" class="panel" style="display:none">
                <div style="display:flex;gap:12px;flex-direction:column">
                    <div style="display:flex;justify-content:space-between;align-items:center">
                        <strong>Bon / Setări</strong>
                        <div class="actions">
                            <button id="btn-download-receipt">Generare DOCX</button>
                            <button id="btn-print-receipt">Print Bon</button>
                        </div>
                    </div>

                    <div style="display:flex;gap:12px;align-items:flex-start">
                        <div style="flex:1;max-width:420px">
                            <h4>Date Firmă</h4>
                            <label for="company-name">Nume Firmă</label>
                            <input id="company-name" placeholder="Nume firmă">
                            <label for="company-cui">CUI</label>
                            <input id="company-cui" placeholder="CUI">
                            <label for="company-reg">Nr. Reg. Com.</label>
                            <input id="company-reg" placeholder="Nr. Reg. Com.">
                            <label for="company-addr">Adresă</label>
                            <input id="company-addr" placeholder="Adresă">
                            <div style="margin-top:8px"><button id="btn-save-company">Salvează</button></div>
                        </div>

                        <div style="flex:1">
                            <h4>Previzualizare Bon</h4>
                            <div id="receipt-container" style="border:1px dashed #ddd;padding:12px;border-radius:6px;background:#fff;max-width:320px">
                                <div id="receipt-preview"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="panel-scan" class="panel" style="display:none">
                <div style="display:flex;gap:12px;flex-direction:column">
                    <div style="display:flex;gap:8px;align-items:center">
                        <button id="btn-start-scan">Start Camera Scan</button>
                        <button id="btn-stop-scan" disabled>Stop</button>                    
                        <button id="btn-resume" style="display:none" title="Resume live scanning">✕</button>
                        <!-- camera selection removed (app will prefer ultrawide back camera by default) -->
                        <small class="hint">Tip: allow camera, align barcode with the red line</small>
                    </div>
                    <div id="perm-hint" style="margin-top:8px;color:#8b5cf6;font-weight:600"></div>

                    <div class="scanner-wrap" style="height:420px">
                        <video id="video" playsinline></video>
                        <div class="scanner-overlay">
                            <div class="scanner-guide"></div>
                            <div class="red-line" aria-hidden="true"></div>
                            <button id="btn-torch" title="Toggle torch" style="position:absolute;right:12px;top:12px;z-index:10;padding:8px;border-radius:8px;border:none;background:rgba(0,0,0,0.6);color:white;backdrop-filter:blur(6px)">⚡</button>
                            <div class="scan-flash" id="scan-flash"></div>
                            <canvas id="capture-canvas" style="position:absolute;left:0;top:0;width:100%;height:100%;display:none;border-radius:8px"></canvas>
                        </div>
                    </div>

                    <div id="scan-result" style="display:flex;gap:12px;align-items:flex-start">
                        <div style="flex:1">
                            <strong>Result</strong>
                            <div id="result-text" style="padding:8px;border:1px solid #eee;border-radius:6px;background:#fafafa;min-height:70px"></div>
                        </div>
                        <div style="width:260px">
                            <strong>Found product</strong>
                            <div id="found-product" style="padding:8px;border:1px solid #eee;border-radius:6px;background:#fff;min-height:70px"></div>
                        </div>
                    </div>
                    <div id="cart-panel" style="margin-top:12px;padding:12px;border-radius:8px;border:1px solid rgba(0,0,0,0.06);background:var(--panel)">
                        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px"><strong>Cart</strong><div><button id="btn-clear-cart">Clear Cart</button></div></div>
                        <div id="cart-list" style="max-height:220px;overflow:auto;margin-bottom:8px"></div>
                        <div style="display:flex;justify-content:space-between;align-items:center;">
                            <div><strong>Total</strong></div>
                            <div id="cart-total" style="font-size:18px;font-weight:700">$0.00</div>
                        </div>
                    </div>
                </div>
            </div>

            <footer>
                <div><small class="hint">To add to iPhone home screen: open in Safari → Share → Add to Home Screen.</small></div>
            </footer>
        </main>

        <script>
            // Storage key
            const STORAGE_KEY = 'products-db-v1';

            // DOM
            const tabGenerate = document.getElementById('tab-generate');
            const tabScan = document.getElementById('tab-scan');
            const tabProducts = document.getElementById('tab-products');
            const tabReceipt = document.getElementById('tab-receipt');
            const panelGenerate = document.getElementById('panel-generate');
            const panelScan = document.getElementById('panel-scan');
            const panelProducts = document.getElementById('panel-products');
            const panelReceipt = document.getElementById('panel-receipt');

            const pname = document.getElementById('pname');
            const pdesc = document.getElementById('pdesc');
            const pstock = document.getElementById('pstock');
            const pcode = document.getElementById('pcode');
            const pimage = document.getElementById('pimage');
            const pprice = document.getElementById('pprice');
            const purl = document.getElementById('purl');
            const imagePreview = document.getElementById('image-preview');
            const imagePreviewImg = document.getElementById('image-preview-img');
            const btnGenerate = document.getElementById('btn-generate');
            const btnSave = document.getElementById('btn-save');
            const btnDownload = document.getElementById('btn-download');
            const barcodeSvg = document.getElementById('barcode');

            const productsList = document.getElementById('products-list');
            const btnExport = document.getElementById('btn-export');
            const btnImport = document.getElementById('btn-import');
            const importFile = document.getElementById('import-file');
            // Receipt / company elements
            const companyNameEl = document.getElementById('company-name');
            const companyCuiEl = document.getElementById('company-cui');
            const companyRegEl = document.getElementById('company-reg');
            const companyAddrEl = document.getElementById('company-addr');
            const btnSaveCompany = document.getElementById('btn-save-company');
            const btnDownloadReceipt = document.getElementById('btn-download-receipt');
            const btnPrintReceipt = document.getElementById('btn-print-receipt');
            const receiptPreview = document.getElementById('receipt-preview');

            // Scan elements
            const video = document.getElementById('video');
            const btnStartScan = document.getElementById('btn-start-scan');
            const btnStopScan = document.getElementById('btn-stop-scan');
            const resultText = document.getElementById('result-text');
            const foundProduct = document.getElementById('found-product');

            let products = [];
            let currentBarcodeValue = '';
            let editingOriginalCode = null;
            let lastDeleted = null;
            let undoTimeoutId = null;
            let codeReader = null;
            let selectedImageBase64 = null;
            let scanningPaused = false;
            let lastScanned = {value:null, ts:0};
            const SCAN_COOLDOWN = 1400; // ms
            const cameraSelect = document.getElementById('camera-select'); // may be null now (select removed)
            // hidden canvas to crop video center for scanning (improves detection reliability)
            const scanCanvas = document.createElement('canvas');
            const scanCtx = scanCanvas.getContext('2d');
            let ocrLoopTimer = null;
            let lastOcrDigits = '';
            let barcodeConfirmCounts = {};
            const CONFIRM_THRESHOLD = 2; // how many repeated barcode reads to accept without OCR

            // ZXing decode hints helper: prefer common linear barcode formats (can be adjusted)
            function getZXingHints(){
                if(typeof ZXing === 'undefined' || !ZXing.DecodeHintType) return undefined;
                try{
                    const hints = new Map();
                    const fmts = [
                        ZXing.BarcodeFormat.CODE_128,
                        ZXing.BarcodeFormat.EAN_13,
                        ZXing.BarcodeFormat.EAN_8,
                        ZXing.BarcodeFormat.UPC_A,
                        ZXing.BarcodeFormat.UPC_E,
                        ZXing.BarcodeFormat.CODE_39,
                        ZXing.BarcodeFormat.ITF
                    ];
                    hints.set(ZXing.DecodeHintType.POSSIBLE_FORMATS, fmts);
                    return hints;
                }catch(e){ return undefined; }
            }

            // Helper: start a BarcodeDetector-based scan loop on an existing media stream
            let _detectorLoopHandle = null;
            async function startDetectorOnStream(stream){
                try{
                    if(_detectorLoopHandle){ clearInterval(_detectorLoopHandle); _detectorLoopHandle = null; }
                    video.srcObject = stream; video.setAttribute('playsinline',''); await video.play();
                    const detector = ('BarcodeDetector' in window) ? new BarcodeDetector({formats:['ean_13','code_128','ean_8','upc_e','upc_a']}) : null;
                    if(!detector){ console.warn('No BarcodeDetector available for manual stream.'); return; }
                    const loop = async ()=>{
                        try{
                            if(video.paused || video.ended) return;
                            const vw = video.videoWidth || video.clientWidth;
                            const vh = video.videoHeight || video.clientHeight;
                            if(!vw||!vh) return;
                            const cw = Math.floor(vw * 0.6);
                            const ch = Math.max(24, Math.floor(vh * 0.14));
                            const sx = Math.floor((vw - cw)/2);
                            const sy = Math.max(0, Math.floor(vh*0.55 - ch/2));
                            scanCanvas.width = cw; scanCanvas.height = ch;
                            scanCtx.drawImage(video, sx, sy, cw, ch, 0, 0, cw, ch);
                            const barcodes = await detector.detect(scanCanvas);
                            if(barcodes && barcodes.length){
                                const v = barcodes[0].rawValue;
                                const now = Date.now(); if(lastScanned.value===v && (now-lastScanned.ts)<SCAN_COOLDOWN) return;
                                lastScanned={value:v,ts:now}; resultText.textContent=v; const flash=document.getElementById('scan-flash'); if(flash){flash.classList.add('scan-active'); setTimeout(()=>flash.classList.remove('scan-active'),180);} 
                                barcodeConfirmCounts[v] = (barcodeConfirmCounts[v]||0)+1;
                                if(lastOcrDigits && extractDigits(v)===lastOcrDigits){ handleDetectedBarcode(v, scanCanvas); return; }
                                if(barcodeConfirmCounts[v]>=CONFIRM_THRESHOLD){ handleDetectedBarcode(v, scanCanvas); return; }
                            }
                        }catch(e){ console.warn('detector loop error', e); }
                    };
                    // run loop on interval
                    _detectorLoopHandle = setInterval(loop, 300);
                    // run immediately
                    loop();
                }catch(e){ console.warn('startDetectorOnStream failed', e); }
            }

            // Dark mode toggle
            const btnDark = document.getElementById('btn-darkmode');
            function applyDarkMode(enabled){
                // default is dark; toggling light-mode class
                if(enabled) document.documentElement.classList.remove('light-mode'); else document.documentElement.classList.add('light-mode');
                localStorage.setItem('dark-mode', enabled? '1':'0');
            }
            btnDark.onclick = ()=>{ const on = !(localStorage.getItem('dark-mode')==='1'); applyDarkMode(on); btnDark.textContent = on? 'Light':'Dark'; };
            // apply saved preference
            if(localStorage.getItem('dark-mode')==='1'){ applyDarkMode(true); btnDark.textContent='Light'; } else { btnDark.textContent='Dark'; }

            // insecure origin check (show a short message; user will deploy to GitHub Pages)
            const insecureWarning = document.getElementById('insecure-warning');
            const isSecureContext = (location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1');
            if(!isSecureContext){ insecureWarning.style.display = 'block'; }

            // permission hint UI
            const permHint = document.getElementById('perm-hint');
            function setPermHint(msg, color){ if(!permHint) return; permHint.textContent = msg; if(color) permHint.style.color = color; }

            // Request camera permission proactively and return true if granted
            async function requestCameraPermission(){
                if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
                    setPermHint('Camera not supported by this browser.', '#d97706');
                    return false;
                }
                // If insecure origin, warn and don't try (permission will be blocked)
                if(!(location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1')){
                    setPermHint('Page not served over HTTPS — camera permission will be blocked. Deploy to GitHub Pages or use HTTPS.', '#b91c1c');
                    return false;
                }
                try{
                    // Try Permissions API first for a quick check
                    if(navigator.permissions && navigator.permissions.query){
                        try{
                            const p = await navigator.permissions.query({name: 'camera'});
                            if(p.state === 'granted'){ setPermHint('Camera permission already granted.', '#059669'); return true; }
                            if(p.state === 'denied'){ setPermHint('Camera permission was denied. Enable camera access in browser settings.', '#b91c1c'); return false; }
                            // if 'prompt', we'll request below
                        }catch(e){ /* some browsers don't support name:'camera' */ }
                    }

                    // Request a minimal generic video stream to trigger permission prompt
                    // (don't force facingMode here so browser will prompt and we can enumerate devices)
                    setPermHint('Requesting camera permission...', '#0ea5e9');
                    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                    // got permission; immediately stop tracks since caller will reopen properly
                    stream.getTracks().forEach(t=>t.stop());
                    setPermHint('Camera permission granted. You can start scanning.', '#059669');
                    return true;
                }catch(err){
                    console.warn('getUserMedia error', err);
                    if(err && (err.name === 'NotAllowedError' || err.name === 'SecurityError')){
                        setPermHint('Camera permission blocked. Allow access in the browser prompt or settings.', '#b91c1c');
                    }else if(err && err.name === 'NotFoundError'){
                        setPermHint('No camera found on this device.', '#b91c1c');
                    }else{
                        setPermHint('Camera error: ' + (err && err.message ? err.message : String(err)), '#b91c1c');
                    }
                    return false;
                }
            }

            // Tabs (switch panels and manage camera)
            tabGenerate.onclick = ()=>{tabGenerate.classList.add('active');tabScan.classList.remove('active');tabProducts.classList.remove('active');tabReceipt && tabReceipt.classList.remove('active');panelGenerate.style.display='block';panelScan.style.display='none';panelProducts.style.display='none';panelReceipt && (panelReceipt.style.display='none'); stopCameraScan(); }
            tabScan.onclick = async ()=>{tabScan.classList.add('active');tabGenerate.classList.remove('active');tabProducts.classList.remove('active');tabReceipt && tabReceipt.classList.remove('active');panelScan.style.display='block';panelGenerate.style.display='none';panelProducts.style.display='none';panelReceipt && (panelReceipt.style.display='none');
                // proactively request permission so browser shows prompt immediately
                const ok = await requestCameraPermission();
                if(ok){ startCameraScan(); }else{ /* permission not granted or blocked; user will see guidance in UI */ }
            }
            tabProducts.onclick = ()=>{ tabProducts.classList.add('active'); tabGenerate.classList.remove('active'); tabScan.classList.remove('active'); tabReceipt && tabReceipt.classList.remove('active'); panelProducts.style.display='block'; panelGenerate.style.display='none'; panelScan.style.display='none'; panelReceipt && (panelReceipt.style.display='none'); stopCameraScan(); }
            if(tabReceipt){
                tabReceipt.onclick = ()=>{
                    tabReceipt.classList.add('active');
                    tabGenerate.classList.remove('active');
                    tabScan.classList.remove('active');
                    tabProducts.classList.remove('active');
                    panelReceipt.style.display = 'block';
                    panelGenerate.style.display = 'none';
                    panelScan.style.display = 'none';
                    panelProducts.style.display = 'none';
                    stopCameraScan();
                    // load settings and render preview
                    loadCompanySettings();
                    renderReceipt();
                };
            }

            // Load/save
            function loadProducts(){
                try{
                    const raw=localStorage.getItem(STORAGE_KEY);
                    products = raw?JSON.parse(raw):[];
                }catch(e){products=[]}
                renderProducts();
            }
            function saveProducts(){localStorage.setItem(STORAGE_KEY,JSON.stringify(products));renderProducts();}

            function renderProducts(){
                productsList.innerHTML='';
                if(!products.length){productsList.innerHTML='<div class="hint">No products yet.</div>';return}
                products.slice().reverse().forEach((p,idx)=>{
                    const el=document.createElement('div');el.className='product';
                    el.innerHTML = `<div style="display:flex;gap:8px"><div style="width:76px;height:76px;flex:0 0 76px;border:1px solid #eee;border-radius:6px;display:flex;align-items:center;justify-content:center">${p.image?'<img src="'+p.image+'" class="thumb">':'<small class="hint">No image</small>'}</div><div style="flex:1"><strong>${escapeHtml(p.name)}</strong><div style="font-size:13px;color:#555">${escapeHtml(p.desc)}</div><div style="margin-top:6px"><strong>Code:</strong> ${p.code} • <strong>Stock:</strong> ${escapeHtml(p.stock)} • <strong>Price:</strong> ${escapeHtml(p.price||'')}</div>${p.url?'<div style="margin-top:6px"><a href="'+escapeHtml(p.url)+'" target="_blank" rel="noopener">Open product page</a></div>':''}</div><div style="display:flex;flex-direction:column;gap:6px"><button data-code="${p.code}" class="btn-edit">Edit</button><button data-code="${p.code}" class="btn-copy">Copy</button><button data-code="${p.code}" class="btn-delete">Delete</button></div></div>`;
                    productsList.appendChild(el);
                });
                // attach handlers
                document.querySelectorAll('.btn-delete').forEach(btn=>btn.onclick=(e)=>{const c=e.target.dataset.code; deleteProductByCode(c); });
                document.querySelectorAll('.btn-copy').forEach(btn=>btn.onclick=(e)=>{navigator.clipboard?.writeText(e.target.dataset.code);alert('Copied '+e.target.dataset.code)});
                document.querySelectorAll('.btn-edit').forEach(btn=>btn.onclick=(e)=>{ const code=e.target.dataset.code; startEditProduct(code); });
            }

            // Delete with undo support
            const undoToast = document.getElementById('undo-toast');
            const undoText = document.getElementById('undo-text');
            const undoBtn = document.getElementById('undo-btn');

            function showUndoToast(item){
                lastDeleted = { item, ts: Date.now() };
                undoText.textContent = `Deleted "${item.name || item.code}"`;
                if(undoToast) undoToast.style.display = 'flex';
                if(undoTimeoutId) clearTimeout(undoTimeoutId);
                undoTimeoutId = setTimeout(()=>{ hideUndoToast(); lastDeleted = null; }, 6000);
            }
            function hideUndoToast(){ if(undoToast) undoToast.style.display = 'none'; if(undoTimeoutId){ clearTimeout(undoTimeoutId); undoTimeoutId = null; } }
            if(undoBtn) undoBtn.onclick = ()=>{ if(lastDeleted){ products.push(lastDeleted.item); saveProducts(); lastDeleted = null; hideUndoToast(); } };

            function deleteProductByCode(code){
                const idx = products.findIndex(p=>p.code==code);
                if(idx === -1) return;
                const [removed] = products.splice(idx,1);
                saveProducts();
                showUndoToast(removed);
            }

            // Start editing a product: populate Generate form with product data
            function startEditProduct(code){
                const p = products.find(x=>x.code==code);
                if(!p){ alert('Product not found'); return; }
                // switch to Generate tab
                tabGenerate.click();
                // populate form
                pname.value = p.name || '';
                pdesc.value = p.desc || '';
                pstock.value = p.stock || '';
                pprice.value = p.price || '';
                purl.value = p.url || '';
                pcode.value = p.code || '';
                selectedImageBase64 = p.image || null;
                // show image preview if present
                try{ if(selectedImageBase64 && imagePreviewImg){ imagePreviewImg.src = selectedImageBase64; imagePreview.style.display = 'block'; } else { if(imagePreview) imagePreview.style.display = 'none'; } }catch(e){}
                // render barcode preview
                try{ JsBarcode(barcodeSvg, p.code, {format: 'CODE128', displayValue: true, width:2, height:60}); currentBarcodeValue = p.code; btnSave.disabled = false; btnDownload.disabled = false; }catch(e){}
                // mark editing original code so save can replace correctly
                editingOriginalCode = p.code;
            }

            function escapeHtml(s){if(!s) return ''; return (s+'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')}

            // Barcode generation
            btnGenerate.onclick = ()=>{
                const val = pcode.value.trim() || generateNumericCode();
                currentBarcodeValue = val;
                try{
                    JsBarcode(barcodeSvg, val, {format: 'CODE128', displayValue: true, width:2, height:60});
                    btnSave.disabled = false;
                    btnDownload.disabled = false;
                }catch(err){alert('Barcode generation failed: '+err.message)}
            }

            // image upload
            pimage.onchange = (e)=>{
                const f=e.target.files[0];
                if(!f) return selectedImageBase64=null;
                const fr=new FileReader();
                fr.onload=()=>{selectedImageBase64=fr.result; try{ if(imagePreviewImg){ imagePreviewImg.src = selectedImageBase64; imagePreview.style.display = 'block'; } }catch(e){} };
                fr.readAsDataURL(f);
            }

            btnSave.onclick = ()=>{
                if(!currentBarcodeValue){alert('Generate barcode first');return}
                const obj={code:currentBarcodeValue,name:pname.value||'(no name)',desc:pdesc.value||'',stock:pstock.value||'',price:pprice.value||'',image:selectedImageBase64||null, url: (purl && purl.value) ? purl.value.trim() : ''};
                // if not editing an existing product and a product with same code exists, confirm overwrite
                if(!editingOriginalCode){ const exists = products.find(p=>p.code===obj.code); if(exists){ if(!confirm('A product with this code already exists. Overwrite it?')) return; } }
                // if editing an existing product, remove that original entry first (handles code changes)
                if(editingOriginalCode){ products = products.filter(p => p.code !== editingOriginalCode); }
                // also remove any existing product with the new code to avoid duplicates
                products = products.filter(p=>p.code!==obj.code);
                products.push(obj);
                // clear editing state
                editingOriginalCode = null;
                saveProducts();
                // clear form and preview
                pname.value='';pdesc.value='';pstock.value='';pcode.value='';pimage.value='';purl.value='';selectedImageBase64=null;currentBarcodeValue='';barcodeSvg.innerHTML='';btnSave.disabled=true;btnDownload.disabled=true;
                if(imagePreview){ imagePreviewImg.src=''; imagePreview.style.display='none'; }
            }

            // download barcode PNG
            btnDownload.onclick = ()=>{
                const svg = barcodeSvg.outerHTML;
                const canvas = document.createElement('canvas');
                const svgBlob = new Blob([svg],{type:'image/svg+xml;charset=utf-8'});
                const url = URL.createObjectURL(svgBlob);
                const img = new Image();
                img.onload = ()=>{
                    canvas.width = img.width || 600; canvas.height = img.height || 200;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#fff'; ctx.fillRect(0,0,canvas.width,canvas.height);
                    ctx.drawImage(img,0,0);
                    const png = canvas.toDataURL('image/png');
                    const a = document.createElement('a'); a.href = png; a.download = (pname.value||'barcode') + '.png'; a.click();
                    URL.revokeObjectURL(url);
                };
                img.src = url;
            }

            function generateNumericCode(){
                // create an 12-digit-ish numeric code using timestamp + random
                const t = Date.now().toString();
                const rand = Math.floor(Math.random()*900+100).toString();
                return (t+rand).slice(-12);
            }

            // ----- Receipt / Company settings -----
            const COMPANY_KEY = 'company-settings-v1';
            function loadCompanySettings(){
                try{
                    const raw = localStorage.getItem(COMPANY_KEY);
                    if(!raw) return;
                    const c = JSON.parse(raw);
                    companyNameEl.value = c.name || '';
                    companyCuiEl.value = c.cui || '';
                    companyRegEl.value = c.reg || '';
                    companyAddrEl.value = c.addr || '';
                }catch(e){/* ignore */}
            }
            function saveCompanySettings(){
                try{
                    const c = { name: companyNameEl.value||'', cui: companyCuiEl.value||'', reg: companyRegEl.value||'', addr: companyAddrEl.value||'' };
                    localStorage.setItem(COMPANY_KEY, JSON.stringify(c));
                }catch(e){console.warn(e)}
            }

            function formatCurrency(v){ return '$' + (parseFloat(v)||0).toFixed(2); }

            function renderReceipt(){
                try{
                    const now = new Date();
                    const dateStr = now.toLocaleDateString(); const timeStr = now.toLocaleTimeString();
                    const c = { name: companyNameEl.value||'', cui: companyCuiEl.value||'', reg: companyRegEl.value||'', addr: companyAddrEl.value||'' };
                    let html = '';
                    html += `<div style="text-align:center;font-weight:700;font-size:16px;margin-bottom:6px">BON FISCAL</div>`;
                    html += `<div style="text-align:center;font-size:12px;margin-bottom:8px">${dateStr} ${timeStr}</div>`;
                    if(c.name) html += `<div style="font-size:12px;text-align:center;margin-bottom:6px">${escapeHtml(c.name)}</div>`;
                    if(c.cui) html += `<div style="font-size:11px;text-align:center">CUI: ${escapeHtml(c.cui)}</div>`;
                    if(c.reg) html += `<div style="font-size:11px;text-align:center">Reg: ${escapeHtml(c.reg)}</div>`;
                    if(c.addr) html += `<div style="font-size:11px;text-align:center;margin-bottom:8px">${escapeHtml(c.addr)}</div>`;
                    html += '<div style="border-top:1px dashed #ddd;margin:6px 0"></div>';
                    html += '<table style="width:100%;font-size:12px;border-collapse:collapse">';
                    html += '<thead><tr><th style="text-align:left">Produs</th><th style="text-align:center">Cant.</th><th style="text-align:right">Preț</th><th style="text-align:right">Subtotal</th></tr></thead>';
                    html += '<tbody>';
                    let total = 0;
                    cart.forEach(it=>{
                        const qty = Number(it.qty)||0; const price = parseFloat(it.price)||0; const sub = qty * price; total += sub;
                        html += `<tr><td>${escapeHtml(it.name)}</td><td style="text-align:center">${qty}</td><td style="text-align:right">${formatCurrency(price)}</td><td style="text-align:right">${formatCurrency(sub)}</td></tr>`;
                    });
                    html += '</tbody>';
                    html += '</table>';
                    html += '<div style="border-top:1px dashed #ddd;margin:8px 0"></div>';
                    html += `<div style="display:flex;justify-content:space-between;font-weight:700;font-size:14px"><div>Total</div><div>${formatCurrency(total)}</div></div>`;
                    receiptPreview.innerHTML = html;
                }catch(e){ console.warn('renderReceipt failed', e); }
            }

            if(btnSaveCompany) btnSaveCompany.onclick = ()=>{ saveCompanySettings(); renderReceipt(); alert('Company settings saved'); };
            if(btnDownloadReceipt) btnDownloadReceipt.onclick = async ()=>{
                try{
                    // use docx to build a simple receipt document
                    if(!window.docx){ alert('docx library not loaded'); return; }
                    const { Document, Packer, Paragraph, TextRun, Table, TableRow, TableCell, WidthType, AlignmentType } = window.docx;
                    const docChildren = [];
                    const now = new Date();
                    docChildren.push(new Paragraph({ alignment: AlignmentType.CENTER, children: [ new TextRun({ text: 'BON FISCAL', bold: true }) ] }));
                    docChildren.push(new Paragraph({ alignment: AlignmentType.CENTER, children: [ new TextRun({ text: now.toLocaleString() }) ] }));
                    const cmp = { name: companyNameEl.value||'', cui: companyCuiEl.value||'', reg: companyRegEl.value||'', addr: companyAddrEl.value||'' };
                    if(cmp.name) docChildren.push(new Paragraph({ alignment: AlignmentType.CENTER, children:[ new TextRun(cmp.name) ] }));
                    if(cmp.cui) docChildren.push(new Paragraph({ alignment: AlignmentType.CENTER, children:[ new TextRun('CUI: ' + cmp.cui) ] }));
                    if(cmp.reg) docChildren.push(new Paragraph({ alignment: AlignmentType.CENTER, children:[ new TextRun('Reg: ' + cmp.reg) ] }));
                    if(cmp.addr) docChildren.push(new Paragraph({ alignment: AlignmentType.CENTER, children:[ new TextRun(cmp.addr) ] }));
                    docChildren.push(new Paragraph({ children:[ new TextRun('') ] }));

                    // table header
                    const rows = [];
                    rows.push(new TableRow({ children: [ new TableCell({ children:[ new Paragraph('Produs') ] }), new TableCell({ children:[ new Paragraph('Cant.') ] }), new TableCell({ children:[ new Paragraph('Preț') ] }), new TableCell({ children:[ new Paragraph('Subtotal') ] }) ] }));
                    let total = 0;
                    cart.forEach(it=>{
                        const qty = Number(it.qty)||0; const price = parseFloat(it.price)||0; const sub = qty*price; total += sub;
                        rows.push(new TableRow({ children: [ new TableCell({ children:[ new Paragraph(it.name) ] }), new TableCell({ children:[ new Paragraph(String(qty)) ] }), new TableCell({ children:[ new Paragraph(formatCurrency(price)) ] }), new TableCell({ children:[ new Paragraph(formatCurrency(sub)) ] }) ] }));
                    });
                    const table = new Table({ rows });
                    docChildren.push(table);
                    docChildren.push(new Paragraph({ children:[ new TextRun('') ] }));
                    docChildren.push(new Paragraph({ alignment: AlignmentType.RIGHT, children:[ new TextRun({ text: 'Total: ' + formatCurrency(total), bold: true }) ] }));

                    const doc = new Document({ sections: [{ children: docChildren }] });
                    const blob = await Packer.toBlob(doc);
                    saveAs(blob, 'bon.docx');
                }catch(e){ console.error('DOCX generation failed', e); alert('Generare DOCX eșuată: ' + (e && e.message ? e.message : e)); }
            };
            if(btnPrintReceipt) btnPrintReceipt.onclick = ()=>{
                try{
                    const outer = document.getElementById('receipt-container').outerHTML;
                    const win = window.open('', '_blank', 'width=420,height=720');
                    const styles = `<style>body{font-family:Arial,Helvetica,sans-serif;padding:8px}table{width:100%;font-size:12px;border-collapse:collapse}th,td{padding:4px} .center{text-align:center}</style>`;
                    win.document.write('<html><head><title>Bon</title>'+styles+'</head><body>'+outer+'</body></html>');
                    win.document.close();
                    win.focus();
                    setTimeout(()=>{ win.print(); /* win.close(); */ }, 250);
                }catch(e){ console.error(e); alert('Print failed: '+(e && e.message?e.message:String(e))); }
            };

                        // Excel export with embedded barcode images using ExcelJS
                        btnExport.onclick = async ()=>{
                                if(!products.length){alert('No products to export');return}
                                if(typeof ExcelJS === 'undefined'){alert('ExcelJS not loaded');return}

                                const wb = new ExcelJS.Workbook();
                                const ws = wb.addWorksheet('Products');
                                ws.columns = [
                                    {header:'Image', key:'img', width:18},
                                    {header:'Code', key:'code', width:22},
                                    {header:'Name', key:'name', width:30},
                                    {header:'Description', key:'desc', width:40},
                                    {header:'Stock', key:'stock', width:12},
                                    {header:'Price', key:'price', width:12}
                                ];

                                // helper: render a barcode SVG to PNG base64 (without prefix)
                                const renderBarcodePngBase64 = (code)=>{
                                    return new Promise((resolve)=>{
                                        try{
                                            const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
                                            JsBarcode(svg, code, {format:'CODE128', displayValue:false, width:2, height:60});
                                            const svgData = new XMLSerializer().serializeToString(svg);
                                            const svgBlob = new Blob([svgData], {type:'image/svg+xml;charset=utf-8'});
                                            const url = URL.createObjectURL(svgBlob);
                                            const img = new Image();
                                            img.onload = ()=>{
                                                const canvas = document.createElement('canvas');
                                                canvas.width = img.naturalWidth || 400;
                                                canvas.height = img.naturalHeight || 120;
                                                const ctx = canvas.getContext('2d');
                                                ctx.fillStyle = '#fff'; ctx.fillRect(0,0,canvas.width,canvas.height);
                                                ctx.drawImage(img,0,0);
                                                const dataUrl = canvas.toDataURL('image/png');
                                                URL.revokeObjectURL(url);
                                                resolve(dataUrl.split(',')[1]);
                                            };
                                            img.onerror = ()=>{ URL.revokeObjectURL(url); resolve(null); };
                                            img.src = url;
                                        }catch(err){console.warn('renderBarcode failed',err); resolve(null)}
                                    })
                                };

                                // add rows and images
                                for(let i=0;i<products.length;i++){
                                    const p = products[i];
                                    const base64 = await renderBarcodePngBase64(p.code);
                                    const row = ws.addRow({img:'', code:p.code, name:p.name, desc:p.desc, stock:p.stock, price:p.price||''});
                                    // row index for ExcelJS is 1-based
                                    if(base64){
                                        try{
                                            const imageId = wb.addImage({base64: base64, extension: 'png'});
                                            // place the image in the first column for this row
                                            ws.addImage(imageId, {tl:{col:0,row:row.number-1}, ext:{width:120, height:60}});
                                            // set row height
                                            ws.getRow(row.number).height = 45;
                                        }catch(err){console.warn('addImage failed',err)}
                                    }
                                }

                                // write workbook to buffer and save
                                try{
                                    const buf = await wb.xlsx.writeBuffer();
                                    saveAs(new Blob([buf]), 'products.xlsx');
                                }catch(err){console.error(err); alert('Export failed: '+err.message)}
                        }

            btnImport.onclick = ()=> importFile.click();
            importFile.onchange = async (e)=>{
                const f = e.target.files[0]; if(!f) return;
                const ext = f.name.split('.').pop().toLowerCase();
                const data = await f.arrayBuffer();
                let workbook;
                try{ workbook = XLSX.read(data, {type:'array'}); }catch(err){alert('Import failed: '+err.message);return}
                const first = workbook.SheetNames[0];
                const arr = XLSX.utils.sheet_to_json(workbook.Sheets[first]);
                if(!arr.length){alert('No rows found');return}
                // Map rows to products, expecting Code/Name/Description/Stock/Price columns (case-insensitive)
                arr.forEach(r=>{
                    const code = r.Code||r.code||r['Barcode']||'';
                    const name = r.Name||r.name||'';
                    const desc = r.Description||r.description||r.Desc||'';
                    const stock = r.Stock||r.stock||'';
                    const price = r.Price||r.price||'';
                    if(!code) return;
                    // keep existing image if any
                    const existing = products.find(p=>p.code==code);
                    products = products.filter(p=>p.code!=code);
                    products.push({code, name, desc, stock, price, image: existing?existing.image:null});
                });
                saveProducts();
                alert('Import complete');
            }

            // Scanning - start/stop helpers with rear-camera preference and debounce
            async function startCameraScan(opts){
                opts = opts || {};
                btnStartScan.disabled = true; btnStopScan.disabled = false; resultText.textContent=''; foundProduct.innerHTML='';
                scanningPaused = false; lastScanned = {value:null, ts:0};
                barcodeConfirmCounts = {};
                try{
                    // reset any previous reader to avoid freezing when switching cameras
                    try{ if(codeReader) { codeReader.reset(); } }catch(e){ console.warn('reset reader', e); }
                    // create reader with format hints to bias decoding towards common linear symbologies
                    const hints = getZXingHints();
                    codeReader = new ZXing.BrowserMultiFormatReader(hints);
                    video.setAttribute('playsinline', '');
                    const devices = await codeReader.listVideoInputDevices();
                    let preferred = undefined;
                                        if(devices && devices.length){
                                                                // prefer an ultra-wide back camera when available (user requested ultrawide)
                                                                const ultraRegex = /(ultra|ultrawide|ultra-wide|wideangle|0\.5x|0\.3x|ultra wide)/i;
                                                                const backRegex = /(back|rear|environment|main)/i;
                                                                // try to find a back-facing ultra-wide camera first, then any ultra-wide, then any back camera
                                                                let p = devices.find(d=> backRegex.test(d.label) && ultraRegex.test(d.label));
                                                                if(!p) p = devices.find(d=> ultraRegex.test(d.label));
                                                                if(!p) p = devices.find(d=> backRegex.test(d.label));
                                                                if(!p) p = devices[devices.length-1] || devices[0];
                                                                preferred = p;
                                            // if cameraSelect exists (rare), populate it — otherwise ignore (UI removed)
                                            if(cameraSelect){
                                                cameraSelect.innerHTML = '';
                                                devices.forEach((d, i)=>{ const opt = document.createElement('option'); opt.value = d.deviceId; opt.text = d.label || ('Camera '+ (i+1)); cameraSelect.appendChild(opt); });
                                                try{ cameraSelect.value = preferred.deviceId; cameraSelect.style.display = devices.length > 1 ? 'inline-block' : 'none'; }catch(e){}
                                            }
                                        }
                                        const deviceId = (opts.forceDeviceId) ? opts.forceDeviceId : ((cameraSelect && cameraSelect.value) ? cameraSelect.value : (preferred ? preferred.deviceId : undefined));
                    // start ZXing decode on the chosen device
                    codeReader.decodeFromVideoDevice(deviceId, video, (result, err) => {
                        if(result){
                            const text = result.getText();
                            const now = Date.now();
                            if(scanningPaused) return;
                            if(lastScanned.value === text && (now - lastScanned.ts) < SCAN_COOLDOWN) return;
                            lastScanned = {value:text, ts:now};
                            scanningPaused = true; setTimeout(()=>{scanningPaused=false}, SCAN_COOLDOWN);
                            resultText.textContent = text;
                            const flash = document.getElementById('scan-flash'); if(flash){ flash.classList.add('scan-active'); setTimeout(()=>flash.classList.remove('scan-active'), 180); }
                            // draw a small crop around the red-line area for OCR cross-validation
                            try{
                                const vw = video.videoWidth || video.clientWidth || 640;
                                const vh = video.videoHeight || video.clientHeight || 480;
                                const cw = Math.floor(vw * 0.6);
                                const ch = Math.max(32, Math.floor(vh * 0.16));
                                const sx = Math.max(0, Math.floor((vw - cw)/2));
                                const sy = Math.max(0, Math.floor(vh*0.55 - ch/2));
                                scanCanvas.width = cw; scanCanvas.height = ch;
                                scanCtx.drawImage(video, sx, sy, cw, ch, 0, 0, cw, ch);
                            }catch(e){ /* ignore */ }
                            // update confirm counts
                            barcodeConfirmCounts[text] = (barcodeConfirmCounts[text]||0) + 1;
                            // if OCR matches lastOcrDigits or confirm count reached, accept immediately
                            if(lastOcrDigits && extractDigits(text) === lastOcrDigits){
                                handleDetectedBarcode(text, scanCanvas);
                            }else if(barcodeConfirmCounts[text] >= CONFIRM_THRESHOLD){
                                handleDetectedBarcode(text, scanCanvas);
                            }else{
                                // not yet confirmed; keep scanning
                                resultText.textContent = text + ' (waiting OCR)';
                            }
                        }
                        if(err && !(err instanceof ZXing.NotFoundException)){
                            console.warn(err);
                        }
                    });

                    // After ZXing starts, check whether the active track is front-facing.
                    // On some iOS browsers the default stream may still be the front camera; if so,
                    // stop ZXing and open an explicit back-camera stream and run the detector loop.
                    setTimeout(async ()=>{
                        try{
                            const s = video.srcObject;
                            if(!s) return;
                            const track = s.getVideoTracks && s.getVideoTracks()[0];
                            const settings = track && track.getSettings ? track.getSettings() : {};
                            const facing = settings.facingMode || '';
                            const label = track && track.label ? track.label : '';
                            if(facing === 'user' || /front|user/i.test(label)){
                                try{ codeReader.reset(); }catch(e){}
                                // pick a preferred back camera deviceId if available
                                const all = await navigator.mediaDevices.enumerateDevices();
                                const vids = all.filter(d=>d.kind==='videoinput');
                                let preferred = null;
                                for(const d of vids){
                                    const L = (d.label||'').toLowerCase();
                                    if(/back|rear|environment|trase|posterior|espate/i.test(L)) { preferred = d; break; }
                                }
                                if(!preferred && vids.length>1){ preferred = vids[vids.length-1]; }
                                if(preferred){
                                    try{
                                        const constraints = {video:{ deviceId: { exact: preferred.deviceId }, facingMode: { exact: 'environment' }, width: { ideal: 1280 }, height: { ideal: 720 }, advanced:[{zoom:1.0}] }};
                                        const stream = await navigator.mediaDevices.getUserMedia(constraints);
                                        await startDetectorOnStream(stream);
                                    }catch(e){ console.warn('failed to open explicit back stream', e); }
                                }
                            }
                        }catch(e){ console.warn('facing check failed', e); }
                    }, 600);
                    // After stream attachment, verify torch capability but avoid opening additional streams
                    // which can interfere with live decoding (especially on iOS). We only check the
                    // active track capabilities and inform the user if torch isn't available.
                    setTimeout(()=>{
                        try{
                            const s = video.srcObject;
                            if(!s) return;
                            const track = s.getVideoTracks && s.getVideoTracks()[0];
                            if(!track) return;
                            const caps = track.getCapabilities ? track.getCapabilities() : {};
                            if(caps && caps.torch){
                                // torch supported — no action needed
                                return;
                            }
                            // If running on iOS Safari, torch is generally unsupported in the browser.
                            const ua = navigator.userAgent || '';
                            if(/iPhone|iPad|iPod/i.test(ua) && /Safari/i.test(ua) && !/CriOS|FxiOS|Chrome/i.test(ua)){
                                setPermHint('Flash/torch is not supported by iOS Safari.', '#b91c1c');
                                return;
                            }
                            // Inform user that the current camera doesn't expose torch capability.
                            setPermHint('Current camera does not expose flash/torch capability in this browser.', '#b91c1c');
                        }catch(e){ console.warn('torch-capability check failed', e); }
                    }, 900);
                    // Do not force 1x zoom — allow ultra-wide stream characteristics so scanning uses that camera.
                    // If needed, device-specific zoom adjustments could be applied here, but we avoid forcing zoom.
                    // start OCR loop in parallel for cross-validation
                    try{ startOCRLoop(); }catch(e){ console.warn('startOCRLoop failed', e); }
                }catch(e){
                    console.warn('ZXing start failed, falling back to BarcodeDetector if available:', e);
                    try{
                        // request a stream with the selected device if available, otherwise prefer rear (exact) camera and request 1x zoom
                        const constraints = cameraSelect && cameraSelect.value ? { video: { deviceId: { exact: cameraSelect.value }, advanced: [{ zoom: 1.0 }] } } : { video: { facingMode: { exact: 'environment' }, advanced: [{ zoom: 1.0 }] } };
                        const stream = await navigator.mediaDevices.getUserMedia(constraints);
                        // attach stream and ensure playsinline for mobile
                        video.srcObject = stream; video.setAttribute('playsinline',''); await video.play();
                        // start OCR loop in parallel
                        try{ startOCRLoop(); }catch(e){ console.warn('startOCRLoop failed', e); }
                        const detector = ('BarcodeDetector' in window) ? new BarcodeDetector({formats:['ean_13','code_128','ean_8','upc_e','upc_a']}) : null;
                        if(!detector){console.warn('No BarcodeDetector available.');}
                        const scanLoop = async ()=>{
                            if(video.paused || video.ended) return;
                            try{
                                if(detector){
                                    // crop center region to improve detection for small/close barcodes
                                    const vw = video.videoWidth || video.clientWidth;
                                    const vh = video.videoHeight || video.clientHeight;
                                    if(vw && vh){
                                                        // use a smaller crop and lower resolution for faster detection
                                                        const cw = Math.floor(vw * 0.6);
                                                        const ch = Math.floor(vh * 0.28);
                                        const sx = Math.floor((vw - cw)/2);
                                        const sy = Math.floor((vh - ch)/2);
                                        scanCanvas.width = cw; scanCanvas.height = ch;
                                        scanCtx.drawImage(video, sx, sy, cw, ch, 0, 0, cw, ch);
                                        const barcodes = await detector.detect(scanCanvas);
                                        if(barcodes && barcodes.length){
                                            const v = barcodes[0].rawValue; const now = Date.now(); if(lastScanned.value===v && (now-lastScanned.ts)<SCAN_COOLDOWN) return; lastScanned={value:v,ts:now}; resultText.textContent=v; const flash=document.getElementById('scan-flash'); if(flash){flash.classList.add('scan-active'); setTimeout(()=>flash.classList.remove('scan-active'),180);} 
                                            barcodeConfirmCounts[v] = (barcodeConfirmCounts[v]||0) + 1;
                                            if(lastOcrDigits && extractDigits(v) === lastOcrDigits){ handleDetectedBarcode(v, scanCanvas); return; }
                                            if(barcodeConfirmCounts[v] >= CONFIRM_THRESHOLD){ handleDetectedBarcode(v, scanCanvas); return; }
                                            return;
                                        }
                                    }else{
                                        // fallback to direct detect on video element
                                        const barcodes = await detector.detect(video);
                                                        if(barcodes && barcodes.length){ const v = barcodes[0].rawValue; const now = Date.now(); if(lastScanned.value===v && (now-lastScanned.ts)<SCAN_COOLDOWN) return; lastScanned={value:v,ts:now}; resultText.textContent=v; const flash=document.getElementById('scan-flash'); if(flash){flash.classList.add('scan-active'); setTimeout(()=>flash.classList.remove('scan-active'),180);} try{ scanCanvas.width = 1; scanCanvas.height = 1; /* ensure canvas exists */ }catch(e){} barcodeConfirmCounts[v] = (barcodeConfirmCounts[v]||0)+1; if(lastOcrDigits && extractDigits(v)===lastOcrDigits){ handleDetectedBarcode(v, scanCanvas); } else if(barcodeConfirmCounts[v]>=CONFIRM_THRESHOLD){ handleDetectedBarcode(v, scanCanvas); } return; }
                                    }
                                }
                            }catch(err){console.warn(err)}
                                // throttle detection loop for performance (scan every ~120ms)
                                setTimeout(()=>{ requestAnimationFrame(scanLoop); }, 120);
                        };
                        scanLoop();
                    }catch(err){alert('Could not start camera: '+err.message);btnStartScan.disabled=false;btnStopScan.disabled=true}
                }
            }

            function stopCameraScan(){
                btnStartScan.disabled = false; btnStopScan.disabled = true; resultText.textContent='';
                if(codeReader){ try{ codeReader.reset(); }catch(e){console.warn(e)} }
                try{ if(torchOn){ setTorch(false); } }catch(e){}
                if(video && video.srcObject){ const tracks = video.srcObject.getTracks(); tracks.forEach(t=>t.stop()); video.srcObject=null; }
                scanningPaused = false; lastScanned = {value:null, ts:0};
                // reset OCR loop and confirm counters
                stopOCRLoop();
                barcodeConfirmCounts = {};
            }

            // bind buttons
            btnStartScan.onclick = async ()=>{
                const ok = await requestCameraPermission();
                if(ok) startCameraScan();
            };
            // torch toggle (best-effort)
            const btnTorch = document.getElementById('btn-torch');
            let torchOn = false;
            async function setTorch(on){
                try{
                    const stream = video.srcObject;
                    if(!stream){ alert('Camera not started'); return; }
                    const track = stream.getVideoTracks()[0];
                    if(!track) return;
                    const caps = track.getCapabilities ? track.getCapabilities() : {};
                    if(caps.torch || (caps.torch === undefined && 'torch' in caps)){
                        await track.applyConstraints({ advanced: [{ torch: on }] });
                        torchOn = on; btnTorch.textContent = on? '🔦':'⚡';
                        return;
                    }
                    // try ImageCapture as fallback
                    if(window.ImageCapture){
                        const ic = new ImageCapture(track);
                        if(ic && typeof ic.setOptions === 'function'){
                            await ic.setOptions({ torch: on }); torchOn = on; btnTorch.textContent = on? '🔦':'⚡'; return;
                        }
                    }
                    alert('Torch not supported on this device/browser');
                }catch(e){ console.warn('setTorch failed', e); alert('Torch error: ' + (e && e.message?e.message:String(e))); }
            }
            if(btnTorch) btnTorch.onclick = ()=>{ setTorch(!torchOn); };
            btnStopScan.onclick = stopCameraScan;
            const btnTestCamera = document.getElementById('btn-test-camera');
            // Quick camera test: enumerate devices and open a basic stream (separate from ZXing)
            btnTestCamera.onclick = async ()=>{
                try{
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    console.log('devices', devices);
                    const cams = devices.filter(d=>d.kind==='videoinput');
                    if(!cams.length){ alert('No camera devices found'); return; }
                    const deviceId = cameraSelect && cameraSelect.value ? cameraSelect.value : cams[0].deviceId;
                    const stream = await navigator.mediaDevices.getUserMedia({video: { deviceId: { exact: deviceId } }});
                    // attach temporarily to video element
                    video.srcObject = stream; await video.play();
                    alert('Camera stream started for test. Check video preview.');
                }catch(err){
                    console.error('Test camera failed', err);
                    alert('Camera test error: '+ (err && err.message ? err.message : String(err)));
                }
            };
            const btnCapture = document.getElementById('btn-capture');
            const btnResume = document.getElementById('btn-resume');
            const btnFocus = document.getElementById('btn-focus');
            const captureCanvas = document.getElementById('capture-canvas');
            const captureCtx = captureCanvas.getContext('2d');
            let frozen = false;

            // Capture button: if camera not running, start scanner; otherwise freeze frame and try immediate decode
            btnCapture.onclick = async ()=>{
                // if camera not started, request permission and start scanning
                if(!video.srcObject){
                    const ok = await requestCameraPermission();
                    if(!ok){ return; }
                    await startCameraScan();
                    return;
                }
                // draw current frame into capture canvas sized to video pixel size
                const vw = video.videoWidth || video.clientWidth;
                const vh = video.videoHeight || video.clientHeight;
                if(!vw || !vh){ alert('Video not ready yet'); return; }
                captureCanvas.width = vw; captureCanvas.height = vh;
                captureCtx.drawImage(video, 0, 0, vw, vh);
                // show canvas overlay (freeze effect)
                captureCanvas.style.display = 'block';
                video.style.display = 'none';
                frozen = true;
                // stop live decoding
                try{ if(codeReader) codeReader.reset(); }catch(e){console.warn(e)}
                // try decode from the frozen canvas using BarcodeDetector if available, otherwise fallback to ZXing image decode
                try{
                    let found = false;
                    if('BarcodeDetector' in window){
                        try{
                            const detector = new BarcodeDetector({formats:['ean_13','code_128','ean_8','upc_e','upc_a']});
                            const barcodes = await detector.detect(captureCanvas);
                            if(barcodes && barcodes.length){ const v = barcodes[0].rawValue; resultText.textContent = v; handleDetectedBarcode(v, captureCanvas); found = true; }
                        }catch(e){ console.warn('BarcodeDetector on canvas failed', e); }
                    }
                    if(!found){
                        // fallback to ZXing decode from the canvas image
                        const tryZX = await decodeCanvasWithZXing(captureCanvas);
                        if(tryZX){ resultText.textContent = tryZX; handleDetectedBarcode(tryZX, captureCanvas); found = true; }
                    }
                    if(!found){ resultText.textContent = '(No code detected in frozen image)'; }
                }catch(err){ console.warn('Frozen decode error', err); resultText.textContent = '(Error decoding frozen image)'; }
                // show resume button
                btnResume.style.display = 'inline-block';
            };

            // ZXing fallback: decode from a canvas by creating an image and using ZXing's image decoder
            async function decodeCanvasWithZXing(canvas){
                if(typeof ZXing === 'undefined') return null;
                try{
                    // scale the canvas down to reduce ZXing decoding time (max dimension limited)
                    const maxDim = 800;
                    let tw = canvas.width, th = canvas.height;
                    if(tw > maxDim){ const scale = maxDim / tw; tw = Math.floor(tw * scale); th = Math.floor(th * scale); }
                    if(th > maxDim){ const scale = maxDim / th; tw = Math.floor(tw * scale); th = Math.floor(th * scale); }
                    const tmp = document.createElement('canvas'); tmp.width = Math.max(1, tw); tmp.height = Math.max(1, th); const tctx = tmp.getContext('2d');
                    tctx.drawImage(canvas, 0, 0, canvas.width, canvas.height, 0, 0, tmp.width, tmp.height);
                    const dataUrl = tmp.toDataURL('image/png');
                    const img = new Image(); img.src = dataUrl; await new Promise((res, rej)=>{ img.onload = res; img.onerror = rej; });
                    // create a fresh reader for image decode to avoid interfering with live reader
                    const reader = new ZXing.BrowserMultiFormatReader(getZXingHints());
                    if(typeof reader.decodeFromImageElement === 'function'){
                        const resObj = await reader.decodeFromImageElement(img);
                        if(resObj && resObj.getText) return resObj.getText();
                    }else if(typeof reader.decodeFromImage === 'function'){
                        const resObj = await reader.decodeFromImage(img);
                        if(resObj && resObj.getText) return resObj.getText();
                    }
                }catch(e){ console.warn('ZXing canvas decode failed', e); }
                return null;
            }

            // Resume scanning: hide capture canvas and restart live scanning
            btnResume.onclick = async ()=>{
                if(frozen){
                    captureCanvas.style.display = 'none';
                    video.style.display = 'block';
                    frozen = false;
                    btnResume.style.display = 'none';
                    // restart scanning
                    startCameraScan();
                }
            };

            // Focus button: best-effort applyConstraints to request autofocus without restarting camera
            btnFocus.onclick = async ()=>{
                if(!video.srcObject){ alert('Camera not started'); return; }
                try{
                    const track = video.srcObject.getVideoTracks()[0];
                    if(!track){ alert('No video track'); return; }
                    const caps = track.getCapabilities ? track.getCapabilities() : {};
                    if(caps.focusMode){
                        try{
                            await track.applyConstraints({advanced:[{focusMode: 'continuous'}]});
                            setPermHint('Requested continuous focus (if supported).', '#059669');
                        }catch(e){ console.warn('focus applyConstraints failed', e); setPermHint('Focus request failed: ' + (e && e.message ? e.message : String(e)), '#b91c1c'); }
                        return;
                    }
                    if(caps.focusDistance){
                        try{
                            const min = (caps.focusDistance && typeof caps.focusDistance.min === 'number') ? caps.focusDistance.min : 0;
                            const max = (caps.focusDistance && typeof caps.focusDistance.max === 'number') ? caps.focusDistance.max : min;
                            const mid = (min+max)/2;
                            await track.applyConstraints({advanced:[{focusDistance: mid}]});
                            setPermHint('Requested focus distance (if supported).', '#059669');
                        }catch(e){ console.warn('focus distance apply failed', e); setPermHint('Focus request failed: ' + (e && e.message ? e.message : String(e)), '#b91c1c'); }
                        return;
                    }
                    // If neither capability present, inform user but do NOT restart the camera (restart caused freezes on some devices)
                    setPermHint('Auto-focus not directly supported via browser APIs on this device. Try moving camera closer/further.', '#b91c1c');
                }catch(err){ console.warn(err); setPermHint('Focus request failed: '+(err && err.message?err.message:String(err)), '#b91c1c'); }
            };

            // cameraSelect onchange removed — the app chooses ultrawide back camera by default

            // (Removed manual Force buttons — default selection now prefers ultrawide back camera)

            // Keep capture and scan canvases in sync with video size on resize/orientation changes
            function syncCanvasSizes(){
                try{
                    const vw = video.videoWidth || video.clientWidth || 640;
                    const vh = video.videoHeight || video.clientHeight || 480;
                    // adjust visible capture canvas (overlay) size styles
                    const overlay = document.getElementById('capture-canvas');
                    if(overlay){ overlay.width = vw; overlay.height = vh; }
                    // keep our internal scanCanvas roughly matching video size
                    if(scanCanvas){ scanCanvas.width = Math.floor(vw * 0.8); scanCanvas.height = Math.floor(vh * 0.36); }
                }catch(e){ /* ignore */ }
            }
            window.addEventListener('resize', ()=>{ syncCanvasSizes(); });
            window.addEventListener('orientationchange', ()=>{ setTimeout(syncCanvasSizes, 220); });
            // also sync when video metadata loads
            video.addEventListener('loadedmetadata', ()=>{ syncCanvasSizes(); });

            // ----- OCR + Cross-validation (Barcode vs OCR digits) -----
            let ocrWorker = null;
            async function initOCR(){
                if(typeof Tesseract === 'undefined') return;
                if(ocrWorker) return;
                try{
                    ocrWorker = Tesseract.createWorker({ logger: m=>{} });
                    await ocrWorker.load();
                    await ocrWorker.loadLanguage('eng');
                    await ocrWorker.initialize('eng');
                    await ocrWorker.setParameters({ tessedit_char_whitelist: '0123456789' });
                }catch(e){ console.warn('Tesseract init failed', e); ocrWorker = null; }
            }

            async function startOCRLoop(){
                try{ await initOCR(); }catch(e){}
                if(ocrLoopTimer) return;
                const runOnce = async ()=>{
                    try{
                        if(!video || video.paused || video.ended) return;
                        const vw = video.videoWidth || video.clientWidth || 640;
                        const vh = video.videoHeight || video.clientHeight || 480;
                        const cw = Math.floor(vw * 0.6);
                        const ch = Math.max(24, Math.floor(vh * 0.14));
                        const sx = Math.max(0, Math.floor((vw - cw)/2));
                        const sy = Math.max(0, Math.floor(vh*0.55 - ch/2));
                        scanCanvas.width = cw; scanCanvas.height = ch;
                        scanCtx.drawImage(video, sx, sy, cw, ch, 0, 0, cw, ch);
                        if(ocrWorker){
                            const res = await ocrWorker.recognize(scanCanvas);
                            const txt = (res && res.data && res.data.text) ? res.data.text : '';
                            const digits = extractDigits(txt);
                            if(digits && digits.length >= 6){ lastOcrDigits = digits; }
                        }
                    }catch(e){ /* ignore ocr errors */ }
                };
                ocrLoopTimer = setInterval(runOnce, 700);
                // run immediately once
                runOnce();
            }

            function stopOCRLoop(){ if(ocrLoopTimer){ clearInterval(ocrLoopTimer); ocrLoopTimer = null; lastOcrDigits=''; } }
            function extractDigits(s){ return (s||'').replace(/\D/g,''); }
            async function crossValidateBarcode(barcodeText, canvas){
                try{
                    await initOCR();
                    if(!ocrWorker) return { match:false, barcodeDigits: extractDigits(barcodeText), ocrDigits: '' };
                    const res = await ocrWorker.recognize(canvas);
                    const ocrText = (res && res.data && res.data.text) ? res.data.text : (res && res.text ? res.text : '');
                    const ocrDigits = extractDigits(ocrText);
                    const barcodeDigits = extractDigits(barcodeText);
                    return { match: barcodeDigits && ocrDigits && barcodeDigits === ocrDigits, barcodeDigits, ocrDigits };
                }catch(e){ console.warn('crossValidate error', e); return { match:false, barcodeDigits: extractDigits(barcodeText), ocrDigits: '' }; }
            }

            async function handleDetectedBarcode(text, sourceCanvas){
                try{
                    // ensure we have a small crop canvas to OCR; if none provided, attempt to crop around red line
                    if(!sourceCanvas || (sourceCanvas.width===0 && sourceCanvas.height===0)){
                        const vw = video.videoWidth || video.clientWidth || 640;
                        const vh = video.videoHeight || video.clientHeight || 480;
                        const cw = Math.floor(vw * 0.6);
                        const ch = Math.max(32, Math.floor(vh * 0.16));
                        const sx = Math.max(0, Math.floor((vw - cw)/2));
                        // focus crop slightly below center where human-readable digits often sit
                        const sy = Math.max(0, Math.floor(vh*0.55 - ch/2));
                        scanCanvas.width = cw; scanCanvas.height = ch;
                        scanCtx.drawImage(video, sx, sy, cw, ch, 0, 0, cw, ch);
                        sourceCanvas = scanCanvas;
                    }
                    const res = await crossValidateBarcode(text, sourceCanvas);
                    if(res.match){
                        // validated — forward to product handler
                        barcodeConfirmCounts[text] = 0;
                        onBarcodeValidated(text);
                    }else{
                        // not matched: show quick hint and keep scanning until someone matches
                        resultText.textContent = text + ' (OCR mismatch)';
                        console.log('Cross-validation mismatch', res);
                    }
                }catch(e){ console.warn('handleDetectedBarcode error', e); }
            }

            function onBarcodeValidated(value){
                const p = products.find(x=>x.code==value);
                if(p){
                    // show product details and add-to-cart controls
                    foundProduct.innerHTML = `<div><strong>${escapeHtml(p.name)}</strong><div style="font-size:13px;color:#555">${escapeHtml(p.desc)}</div><div style="margin-top:6px"><strong>Code:</strong> ${p.code} • <strong>Stock:</strong> ${escapeHtml(p.stock)} • <strong>Price:</strong> ${escapeHtml(p.price||'')}</div>${p.url?'<div style="margin-top:6px"><a href="'+escapeHtml(p.url)+'" target="_blank" rel="noopener">Open product page</a></div>':''}${p.image?'<div style="margin-top:8px"><img src="'+p.image+'" class="thumb"></div>':''}
                        <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
                            <label style="font-size:13px">Qty</label>
                            <input id="cart-qty" type="number" value="1" min="1" style="width:72px;padding:6px;border-radius:6px;border:1px solid #ddd">
                            <button id="btn-add-cart" style="padding:8px 10px">Add to cart</button>
                        </div>
                    </div>`;
                    // wire add to cart (attach handler immediately)
                    const addBtn = document.getElementById('btn-add-cart');
                    const qtyInput = document.getElementById('cart-qty');
                    if(addBtn){
                        addBtn.onclick = ()=>{
                            try{
                                const q = qtyInput ? parseInt(qtyInput.value||'1', 10) : 1;
                                const qty = isNaN(q) ? 1 : qtyInput ? Math.max(1, q) : 1;
                                console.log('Add-to-cart clicked (inline)', {code: p && p.code, qty, product: p});
                                // ensure cart exists
                                if(!Array.isArray(cart)) cart = [];
                                // simple add: increment if exists, otherwise push
                                const existing = cart.find(c=>c.code==p.code);
                                if(existing){ existing.qty = (existing.qty||0) + qty; }
                                else { cart.push({code: p.code, name: p.name, desc: p.desc, price: p.price||0, qty: qty}); }
                                saveCart();
                                // show quick inline confirmation in foundProduct area
                                try{
                                    const note = document.createElement('div'); note.style.marginTop='8px'; note.style.color='#059669'; note.textContent = `Added ${qty} × ${p.name || p.code} to cart`;
                                    foundProduct.appendChild(note);
                                    setTimeout(()=>{ try{ note.remove(); }catch(e){} }, 2500);
                                }catch(e){ console.warn(e); }
                                // scroll cart into view so user sees update
                                try{ const cartListEl = document.getElementById('cart-list'); if(cartListEl) cartListEl.scrollIntoView({behavior:'smooth', block:'center'}); }catch(e){}
                            }catch(err){ console.error('Inline add to cart failed', err); alert('Could not add to cart: ' + (err && err.message ? err.message : String(err))); }
                        };
                    } else {
                        console.warn('Add button not found in DOM');
                    }
                }else{
                    foundProduct.innerHTML = '<div class="hint">Product not found in database.</div>';
                }
            }

            // init
            loadProducts();

            // CART: simple cart stored in localStorage
            const CART_KEY = 'cart-db-v1';
            let cart = [];
            function loadCart(){ try{ const raw = localStorage.getItem(CART_KEY); cart = raw?JSON.parse(raw):[]; }catch(e){ cart=[] } renderCart(); }
            function saveCart(){ localStorage.setItem(CART_KEY, JSON.stringify(cart)); renderCart(); renderReceipt(); }
            function renderCart(){
                const list = document.getElementById('cart-list'); const totalEl = document.getElementById('cart-total');
                if(!list) return;
                list.innerHTML = '';
                if(!cart.length){ list.innerHTML = '<div class="hint">Cart is empty</div>'; totalEl.textContent = '$0.00'; return; }
                let total = 0;
                cart.forEach((it, idx)=>{
                    const row = document.createElement('div'); row.style.display='flex'; row.style.justifyContent='space-between'; row.style.alignItems='center'; row.style.padding='6px 0';
                    const left = document.createElement('div'); left.innerHTML = `<div style="font-weight:600">${escapeHtml(it.name)}</div><div style="font-size:13px;color:#555">${escapeHtml(it.code)} • ${escapeHtml(it.desc||'')}</div>`;
                    const right = document.createElement('div'); right.style.display='flex'; right.style.alignItems='center'; right.style.gap='8px';
                    const qty = document.createElement('input'); qty.type='number'; qty.min='1'; qty.value = it.qty; qty.style.width='64px'; qty.style.padding='6px'; qty.onchange = ()=>{ const v = parseInt(qty.value||'1',10); it.qty = isNaN(v)?1:v; saveCart(); };
                    const price = document.createElement('div'); const pnum = parseFloat(it.price) || 0; price.textContent = '$'+(pnum.toFixed(2));
                    const rm = document.createElement('button'); rm.textContent='Remove'; rm.onclick = ()=>{ cart.splice(idx,1); saveCart(); };
                    right.appendChild(qty); right.appendChild(price); right.appendChild(rm);
                    row.appendChild(left); row.appendChild(right);
                    list.appendChild(row);
                    total += (pnum * (it.qty||1));
                });
                totalEl.textContent = '$' + total.toFixed(2);
                // also update receipt preview when cart changes
                try{ renderReceipt(); }catch(e){}
            }
            function addToCart(code, qty){
                try{
                    // ensure cart array exists
                    if(!Array.isArray(cart)) cart = [];
                    const p = products.find(x=>x.code==code || x.code===code);
                    if(!p){ console.warn('addToCart: product not found for code', code); return false; }
                    const existing = cart.find(c=>c.code==code || c.code===code);
                    if(existing){ existing.qty = (existing.qty||0) + (qty||1); }
                    else { cart.push({code:p.code, name:p.name, desc:p.desc, price:p.price||0, qty: qty||1}); }
                    saveCart();
                    try{ setPermHint('Added to cart', '#059669'); }catch(e){}
                    return true;
                }catch(err){ console.error('addToCart error', err); return false; }
            }
            const btnClearCart = document.getElementById('btn-clear-cart'); if(btnClearCart) btnClearCart.onclick = ()=>{ if(confirm('Clear cart?')){ cart=[]; saveCart(); } };
            // load cart on start
            loadCart();
            // preload saved company settings for receipt preview
            try{ loadCompanySettings(); renderReceipt(); }catch(e){}

            // show PWA install prompt guidance
            window.addEventListener('beforeinstallprompt', (e) => { e.preventDefault(); window.deferredPrompt = e; });
        </script>
    </body>
</html>